# Java集合  

### 1.HashMap排序题，上机题  
### 题目：已知一个HashMap<Integer, User>集合，Use集合有name(String)和age(int)属性。请写出一个方法实现对HashMap的排序功能，该方法接收HashMap<Integer, User>为形参，返回类型为HashMap<Integer, User>，要求对HashMap中的User的age倒叙进行排序。排序是key=value键值对不得拆散。  
  
  注意：__HashMap本身是不可排序的__，但是该道题偏偏让给HashMap排序，那我们就得想在API中有没有这样的Map结构是有序的。__LinkedHashMap__，HashMap的子类，既是Map结构，也是链表结构，有序，那么我们返回LinkedHashMap<Integer, User>即可。___但凡是对集合的操作，我们应该保持一个原则就是能用JDK中的API就用API___，比如排序算法我们不应该去用冒泡或者选择，而是首先想到用Collections集合工具类。  
```java
public class HashMapTest {
	public static void main(String[] args) {
		HashMap<Integer, User> users = new HashMap<>();
		users.put(1, new User("张三", 25));
		users.put(3, new User("李四", 22));
		users.put(2, new User("王五", 28));
		System.out.println(users);
		HashMap<Integer, User> sortMap = sortHashMap(users);
		System.out.println(sortMap);	
		/**
		 * 控制台输出如下：  
		 * {1=User[name=张三, age=25], 2=User[name=王五, age=28], 3=User[name=李四, age=22]}  
		 * {2=User[name=王五, age=28], 1=User[name=张三, age=25], 3=User[name=李四, age=22]}  
		 * 
		 */
	}
	public static HashMap<Integer, User> sortHashMap(HashMap<Integer, User> map) {
		//首先拿到map的键值对集合
		Set<Entry<Integer, User>> entrySet = map.entrySet();
		//将set集合转为List集合，为了使用API工具类的排序方式
		List<Entry<Integer, User>> list = new ArrayList<Entry<Integer, User>>(entrySet);
		//使用Collections集合工具类对list进行排序，排序规则使用匿名内部类实现
		Collections.sort(list, new Comparator<Entry<Integer, User>>() {

			@Override
			public int compare(Entry<Integer, User> o1, Entry<Integer, User> o2) {
				//按要求根据User的age进行倒序排序
				return o2.getValue().getAge() - o1.getValue().getAge();
			}
		});
		//创建一个新的有序HashMap子类的集合
		LinkedHashMap<Integer, User> linkedHashMap = new LinkedHashMap<Integer, User>();
		//将List中的数据存储在LinkedHashMap中
		for (Entry<Integer, User> entry : list ) {
			linkedHashMap.put(entry.getKey(), entry.getValue());
		}
		return linkedHashMap;
	}
}
```  
  
### 2.集合的安全性问题  
### 题目：请问ArrayList、HashSet、HashMap是线程安全的吗？如果不是我想要线程安全的聚合怎么办？  
  
  以上三种集合的方法都没有加锁，显然都是线程不安全的。  
  在集合中 __Vector__ 和 __HashTable__ 都是线程安全的，其各自的核心方法添加上了 __synchronized__ 关键字。  

  Collections工具类提供了相关的API，可以让上面３个不安全的集合变为安全的。  
```java
	Collections.synchronizedCollection(c);
	Collections.synchronizedList(list);
	Collections.synchronizedMap(m);
	Collections.synchronizedSet(s);
```  
上面几个函数都有对应的返回值类型，传入什么类型返回什么类型。打开源码其实实现原理非常简单，就是将集合的核心方法添加上了 __synchronized__ 关键字。  

